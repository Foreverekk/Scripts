/**
 * Script Name: GeneticAlgorithm
 * Description: A library for solving optimization problems using a genetic algorithm.
 * Author: Foreverekk
 */

//
export class GeneticAlgorithm {
    /**
     * Initializes a new instance of the GeneticAlgorithm class.
     *
     * @param {object} options - The options to use for the genetic algorithm.
     * @param {number} options.populationSize - The size of the population.
     * @param {function} options.fitnessFunction - The function to use for evaluating the fitness of each individual in the population.
     * @param {number} options.mutationRate - The rate at which to mutate each individual in the population.
     * @param {number} options.crossoverRate - The rate at which to perform crossover on two individuals in the population.
     */
    constructor({ populationSize, fitnessFunction, mutationRate, crossoverRate }) {
        this.populationSize = populationSize;
        this.fitnessFunction = fitnessFunction;
        this.mutationRate = mutationRate;
        this.crossoverRate = crossoverRate;
        this.population = [];
    }

    /**
     * Initializes the population by calling the given function to generate each individual.
     *
     * @param {function} generateIndividual - A function that generates an individual in the population.
     * @example
     * const ga = new GeneticAlgorithm({
     *     populationSize: 100,
     *     fitnessFunction: (individual) => individual.reduce((a, b) => a + b, 0),
     *     mutationRate: 0.1,
     *     crossoverRate: 0.7,
     * });
     * ga.initializePopulation(() => Array.from({ length: 10 }, () => Math.random()));
     */
    initializePopulation(generateIndividual) {
        this.population = Array.from({ length: this.populationSize }, generateIndividual);
    }

    /**
     * Evolves the current population to a new population by selecting parents,
     * performing crossover, and mutating the resulting children.
     * The new population is generated by repeatedly selecting two parents from
     * the current population and producing two children using crossover and
     * mutation. The fittest individuals of the current population are more likely
     * to be selected as parents. The crossover rate is used to determine the
     * probability of performing crossover on two parents. The mutation rate is
     * used to determine the probability of randomly changing one of the
     * children's genes. The new population replaces the current population.
     */
    evolve() {
        this.population = this.population
            .map((individual) => ({ individual, fitness: this.fitnessFunction(individual) }))
            .sort((a, b) => b.fitness - a.fitness)
            .map(({ individual }) => individual);

        const newPopulation = [];
        while (newPopulation.length < this.populationSize) {
            const [parent1, parent2] = this.selectParents();
            const [child1, child2] = this.crossover(parent1, parent2);
            newPopulation.push(this.mutate(child1), this.mutate(child2));
        }
        this.population = newPopulation.slice(0, this.populationSize);
    }

    /**
     * Selects two parents from the current population based on their fitness.
     * 
     * This method uses a fitness-proportionate selection mechanism where the probability
     * of selecting an individual is proportional to its fitness. It calculates the total
     * fitness of the population and selects individuals by generating a random threshold
     * and accumulating fitness until the threshold is exceeded. This process is repeated
     * to select two parents.
     * 
     * @returns {Array<Object>} An array containing two selected parent individuals.
     */
    selectParents() {
        const totalFitness = this.population.reduce((sum, individual) => sum + this.fitnessFunction(individual), 0);
        const select = () => {
            const threshold = Math.random() * totalFitness;
            let sum = 0;
            for (const individual of this.population) {
                sum += this.fitnessFunction(individual);
                if (sum >= threshold) return individual;
            }
            return this.population[0];
        };
        return [select(), select()];
    }

    /**
     * Performs crossover on two parent individuals to produce two children.
     * If the crossover rate is not exceeded, the two parents are returned unchanged.
     * Otherwise, a random split index is generated and the two parents are split and
     * combined to form the two children. The first child has the first part of the
     * first parent and the second part of the second parent. The second child has the
     * first part of the second parent and the second part of the first parent.
     * @param {Array<number>} parent1 - The first parent individual.
     * @param {Array<number>} parent2 - The second parent individual.
     * @returns {Array<Array<number>>} An array containing the two children.
     */
    crossover(parent1, parent2) {
        if (Math.random() > this.crossoverRate) return [parent1, parent2];
        const split = Math.floor(Math.random() * parent1.length);
        return [
            parent1.slice(0, split).concat(parent2.slice(split)),
            parent2.slice(0, split).concat(parent1.slice(split)),
        ];
    }

    /**
     * Mutates the given individual by randomly changing one of its genes.
     * If the mutation rate is not exceeded, the individual is returned unchanged.
     * Otherwise, a random index is generated and the gene at that index is
     * replaced with a random value.
     * @param {Array<number>} individual - The individual to mutate.
     * @returns {Array<number>} The mutated individual.
     */
    mutate(individual) {
        if (Math.random() > this.mutationRate) return individual;
        const index = Math.floor(Math.random() * individual.length);
        const mutation = Math.random();
        individual[index] = mutation;
        return individual;
    }
}

// Example Usage:
const ga = new GeneticAlgorithm({
    populationSize: 100,
    fitnessFunction: (individual) => -Math.abs(individual.reduce((a, b) => a + b, 0) - 1),
    mutationRate: 0.1,
    crossoverRate: 0.7,
});
ga.initializePopulation(() => Array.from({ length: 10 }, () => Math.random()));
for (let i = 0; i < 100; i++) {
    ga.evolve();
}
console.log('Best Solution:', ga.population[0]);
